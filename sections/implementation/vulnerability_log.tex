\section{Vulnerabilities}
This module uses the result of the fixed-point analysis to detect vulnerabilities in the applicationa.

A definition file is provided that contains sources, sinks and sanitisers which are used to find vulnerabilities in the source code.
A simple text file with two keywords  is used for this purpose.
The keywords ``sources:'' and ``sinks:'' are used to indicate the content of the section.
Each source or sink is written on a separate line.
A sink can have a number of sanitisers attached written with as a comma separated list af an arrow (``\texttt{->}'').
This file is called a trigger word file and an example can be seen in \cref{trigger_word_file}.
\begin{lstlisting}[style=default, caption={How the trigger word file should be defined.}, label={trigger_word_file}]
  sources:
  source_1
  source_2

  sinks:
  sink_1
  sink_2 -> sanitiser_1
  sink_3 -> sanitiser_1, sanitiser_2, sanitiser_3
\end{lstlisting}

After parsing the file all potential vulnerabilities are found and saved in a log.
The vulnerability log contains a list of vulnerabilities.
A vulnerability is an object which consists of a source and a sink and which words triggered them.
A source and a sink have also attached a line number to them, this line number tells where they are located in the source code.
This information is used to make it as easy as possible for the user to find and determine whether the vulnerability found is harmful.
An example of a vulnerability log can be found in \cref{vulnerability_log_example}.
The output shown is after running \pyt{} on \cref{xss}.

\begin{lstlisting}[style=default, caption={An example of how the vulnerability log looks after it found one vulnerability.}, label={vulnerability_log_example}]
1 vulnerability found:
Vulnerability 0:
User input at line 8, trigger word "get": 
	param = request.args.get('param', 'not set')
reaches line 11, trigger word "replace": 
	resp = make_response(html.replace('{{ param }}', param))
\end{lstlisting}
