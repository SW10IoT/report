\section{Surprising features in Python}
When working so close to the specification of a language some weird or surprising structures in the language arise.
While we programmed the conversion from abstract syntax tree to a control flow graph, we had these experiences once in a while, and working with the structures has given us some insight, both in the workings of python and in the details of these interesting structures.
This section will discuss some of these experiences.

\subsection{While - else}
Normally we know \texttt{while} as a simple control structure that has a condition and a body.
The body will execute until the condition is false.
This implementation is also found in Python, but Python has an extra variant of the while loop - an else clause.
An example of a while loop with an else clause can be seen on \cref{surprise_while_else}.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.4\textwidth}
    \begin{lstlisting}[style=python]
while x < threshold:
    if invalid_value(x):
        break
    x += 1
else:
    handle_value()
    \end{lstlisting}
    \caption{A while loop with an else clause}\label{surprise_while_else}
    \end{subfigure}
  ~
    \begin{subfigure}[b]{0.4\textwidth}
      \includegraphics[scale=.5]{./figures/while_break.pdf}
      \caption{Possible flows}\label{surprise_while_else_cfg}
    \end{subfigure}
    
  \caption{An example of a while loop with a break statement}
\end{figure}


The else clause will execute when the condition is false, but if the body is exited by a \texttt{break} statement, the else clause will not be executed.
In the example in \cref{surprise_while_else}, this is being utilised to handle values that are unexpected in some way.
If that is the case, we break the body and do not execute the else clause which contains some logic for the value behaved as expected.

The \texttt{for} loop in Python also has an \texttt{else} clause which works in the same way.
A example of this can be seen in \cref{python:for:else}.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.4\textwidth}
    \begin{lstlisting}[style=python]
for x in range(5):
    if invalid_value(x):
        break
    print(x)
else:
    print('Accepted')
    \end{lstlisting}
    \caption{Code example}\label{python:for:else:code}
  \end{subfigure}
  ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
  %(or a blank line to force the subfigure onto a new line)
  \begin{subfigure}[b]{0.4\textwidth}
    \centering
    \includegraphics[scale=.5]{./figures/for_else.pdf}
    \caption{Possible flows}
    \label{python:for:else:flow}
  \end{subfigure}
  \caption{A \texttt{for} control structure with an \texttt{else} statement}
  \label{python:for:else}
\end{figure}

\subsection{Generator expression}
The Python language has a goal of being simple, explicit and readable\citep{python_zen}.
This can often be seen in some very elegant constructions contained in the language.
One of those is the generator statement, which was discovered during the development of \pyt{}.

A generator expression is a concise notation for a common pattern: iterating over a collection of items and then performing some operation on every element\citep{python_functional}.

\begin{lstlisting}[style=python, caption={Generator expression, stripping white-space from strings}, label={generator_strip}]
strings = ['King Arthur   ', '', '   Queen Elizabeth',
           '', '   Arnold Schwarzenegger   ']

people = (line.strip() for line in strings if line != '')
\end{lstlisting}

In \cref{generator_strip} some file has been parsed into an array.
The resulting strings have some undesirable white-space, and some of the strings are even empty.
The subsequent generator expression handles both of these problems.

A generator expression consists of an expression part and a for part.
The for part is evaluated and the expression is executed on each element of the resulting iterable.
The result is a generator that contains the results.

In \cref{generator_strip} the generator iterates over the strings with the \texttt{for} statement and filters out empty strings with the \texttt{if} statement.
The resulting elements are the stripped of white-space by the initial expression.

The generator in \cref{generator_strip} can be written without using a generator expression.
This can be seen in \cref{generator_corresponding}.
The generator expression is very clear in conveying its purpose while being shorter than the ``old way''.
\begin{lstlisting}[style=python, caption={\Cref{generator_strip} implemented without using an generator expression}, label={generator_corresponding}]
for line in strings:
    if not line != '':
        yield line.strip()
\end{lstlisting}

Python contains similar constructs called the comprehensions which return a list, set or dictionary of the element instead of a generator.
This construct uses square or curly parenthesis instead of round parenthesis, but are not different in any other way.
An example of a list comprehension can be seen in \cref{listcomp}.

\begin{lstlisting}[style=python, caption={The generator from \cref{generator_strip} changed to a list comprehension}, label={listcomp}]
people = [line.strip() for line in strings if line != '']
\end{lstlisting}

\subsection{Parameter Passing}
This section describes how Python deals with parameter passing and is inspired by \citet{parameter_passing}, official documentation for this can be found at \citet{parameter_passing_official}.
This section is included as we were surprised how it is dealt with and it is important to factor in when parameters are assigned in functions.

The most known parameter passing techniques are pass-by-reference and pass-by-value.
A short description of these two will lead up to an explanation of how Python is handling parameter passing.
To illustrate the different approaches the following two functions are used, \cref{parameter_passing:reassign} and \cref{parameter_passing:append}.

\begin{lstlisting}[style=python, caption={Parameter passing: \texttt{reassign} function.}, label={parameter_passing:reassign}]
  def reassign(l):
      l = [1]
\end{lstlisting}

\begin{lstlisting}[style=python, caption={Parameter passing: \texttt{append} function.}, label={parameter_passing:append}]
  def append(l):
      l.append(1)
\end{lstlisting}

\paragraph{Pass-by-reference}
Pass-by-reference is when the argument is directly passed into the function.
Given the object \texttt{l = [0]} when we are using pass-by-reference and calling the function \texttt{reassign}, \cref{parameter_passing:reassign}.
This will change the object \texttt{l} to: \texttt{l = [1]}.
This is because the object is passed directly and this means that the function is operating directly on the object.
The \texttt{append} function also behaves as above so the result is the same: \texttt{l = [1]}.

\paragraph{Pass-by-value}
Pass-by-value is when the argument is copied and passed into the function.
The argument is copied and stored a new place in memory and the copy is passed into the function.
Given the object \texttt{l = [0]} when we are using pass-by-value and calling the function \texttt{reassign}, \cref{parameter_passing:reassign}.
This will change the copied object \texttt{l$'$} to: \texttt{l$'$ = [1]}.
But the object given as argument remains the same as it was not manipulated by the function.
This also applies to the \texttt{append} function, \cref{parameter_passing:append}, where after calling the function \texttt{l = [0]} and \texttt{l$'$ = [1]}.

\paragraph{Pass-by-object-reference}
Pass-by-object-reference is the Python way of handling parameter passing.
This means that the argument is copied but both refer to the same object in memory.
Given the object \texttt{l = [0]} when we are using pass-by-object-reference and calling the function \texttt{reassign}, \cref{parameter_passing:reassign}.
A copy of the argument, \texttt{l$'$} is referring to the same object in memory but has a different name.
So \texttt{reassign} sets \texttt{l$'$ = [1]} but not \texttt{l} because reassign is not manipulating the object but only the name that is referring to it.
When calling the \texttt{append} function the object is referenced and both \texttt{l} and \texttt{l$'$} are changed to \texttt{[1]}.
