As we concluded in \cref{vulnerabilities:detecting}  we are interested in determining when dangerous input from a user is able to reach a place in the code where it can cause damage.
A technique for determining this is static analysis where the source of a program is statically analysed for some property.

This chapter will describe the theory used for building the static analysis engine used by \pyt{}.
It is based on the lecture notes on static analysis in \citet{schwartzbach}.

\paragraph{Undecidable}\label{theory_intro}
As mentioned above we want to track input and determine whether it is harmful or not in the way it is used throughout the application.
Unforturnately, it turns out that we will not be able to provide definite answers to this question, but only qualified approximations.
This is due to Rice's theorem which can be phrased as ``all interesting questions about the behaviour of programs are undecidable'' \citep[p.~3]{schwartzbach}.
These \emph{interesting questions} consitute a rather large group of problems, and our problem is part of this group.

\paragraph{Static analysis}
Static analysis is the theoretical topic that engage in solving this type of problem.
The problem is characterised by setting up a number of rules which define the problem.
The program is then converted into a model which represent the flow of the program.
The solution to the problem will then be gradually approached by an algorithm that applies the defined rules on the model.
The algorithm stops when it can not get closer to an answer.
This result is then the approximation which can be used for further analysis and be the basis of an answer to the problem.

